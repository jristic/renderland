
constant float3 CameraPos = {2,1,1};
constant float3 LookPos = {0,-1,0};

constant float FOV = 3.14/2;
constant float ZNear = 0.1;
constant float ZFar = 10;
constant float Aspect = DisplaySize().x / float(DisplaySize().y);
constant float4x4 ProjectionView = 
	projection(FOV, Aspect, ZNear, ZFar) * lookAt(CameraPos, LookPos);
constant float4x4 InvProjView = inverse(ProjectionView);

tuneable uint NumLights [1, 4] = 1;

ObjImport {
	ObjPath = "../common/monkey.obj";
} monkeyObj

Buffer {
	Flags = { Vertex };
	InitData = monkeyObj.vertices;
} verts

Buffer {
	Flags = { Index, };
	InitData = monkeyObj.indices;
} indices

Buffer {
	ElementSize = 24;
	ElementCount = 4;
	Flags = { Vertex };
	InitData = float {
		5.0, -1.0, 5.0, 0, 1, 0,
		5.0, -1.0, -5.0, 0, 1, 0,
		-5.0, -1.0, 5.0, 0, 1, 0,
		-5.0, -1.0, -5.0, 0, 1, 0,
	};
} planeVerts

Buffer {
	ElementSize = 2;
	ElementCount = 6;
	Flags = { Index };
	InitData = u16 {
		0, 1, 2,
		2, 1, 3,
	};
} planeIndices


Texture {
	Format = R8G8B8A8_UNORM;
	Size = DisplaySize();
	Flags = { RTV, SRV };
} RT

Texture {
	Format = D24_UNORM_S8_UINT;
	Size = { DisplaySize() };
	Flags = { DSV };
} DS

Sampler {
	Filter = { All = Point };
	AddressMode = { UVW=Clamp };
} PointSampler

ComputeShader {
	ShaderPath = "shaders.hlsl";
	EntryPoint = "CSUpdateLights";
} updateShader

Buffer {
	ElementSize = sizeof(updateShader, "LightData");
	ElementCount = NumLights;
	Flags = { Structured };
} LightBuffer

VertexShader {
	ShaderPath = "shaders.hlsl";
	EntryPoint = "VSMain";
} VS
PixelShader {
	ShaderPath = "shaders.hlsl";
	EntryPoint = "PSMain";
} PS



Passes {
	ClearColor{ Target=RT; Color={0,0,0,1}; },
	ClearDepth{ Target=DS; Depth=1; },
	Dispatch {
		Shader = updateShader;
		Groups = {1,1,1};
		Bind LightBufferWrite = LightBuffer;
		setconstant NumLights = NumLights;
		setconstant Time = time();
	},
	Draw {
		Topology = TriList;
		VShader = VS;
		PShader = PS;
		VertexBuffer = verts;
		IndexBuffer = indices;
		RenderTarget = RT;
		DepthStencil = DS;
		SetConstantVs Matrix = ProjectionView;
		Bindps LightBufferRead = LightBuffer;
	},

	Draw {
		Topology = TriList;
		VShader = VS;
		PShader = PS;
		VertexBuffer = planeVerts;
		IndexBuffer = planeIndices;
		RenderTarget = RT;
		DepthStencil = DS;
		SetConstantVs Matrix = ProjectionView;
		Bindps LightBufferRead = LightBuffer;
	},

	Dispatch {
		Shader = ComputeShader {
			ShaderPath = "shaders.hlsl";
			EntryPoint = "CSCopy";
		};
		ThreadPerPixel = true; 
		Bind OutTexture = @BackBuffer;
		Bind InTexture = RT;
		Bind Sampler = PointSampler;
		setconstant TextureSize = DisplaySize();
	}
}
